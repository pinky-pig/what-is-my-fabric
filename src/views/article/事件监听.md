# 事件监听

1. mousewheel - 缩放

这里直接使用 `vueuse/core` 的监听事件 `useEventListener` 监听了。
因为 fabric 生成的 canvas dom是有两个，一个是 upper ，一个是 lower ，对之前保存的 canvas dom 进行监听，监听不到，  
需要对其外面的盒子进行监听.

```ts
import { useFabricStore } from '~/store/modules/fabric'

export const useMouseWheel = () => {
  const fabricStore = useFabricStore()
  useEventListener(fabricStore.wrapperRef, 'wheel', (evt: WheelEvent) => {
    evt.preventDefault()
    console.log(111)
  })
}

```

这里在 canvas ， 滚动鼠标滚轮，就会打印出111


2. 拖拽

这里自然需要监听三个事件 `[mousedown,mousemove,mouseup]`
这里也是使用了 `vueuse/core` 的事件监听函数 `useEventListener`

同时，拖拽画布，需要加一个 ctrl 同时按下的时候，才生效
这里使用 `vueuse/core` 的 `useMagicKeys`事件进行监听

是否正在拖拽中，这里用一个 Boolean 表示，存在 store 中

```ts
// events/useMouseDown.ts
import { isPressedCtrl } from './useKeyStoke'

export const useMouseDown = () => {
  const fabricStore = useFabricStore()
  const [canvas] = useCanvas()
  useEventListener(fabricStore.wrapperRef, 'mousedown', (evt: WheelEvent) => {
    evt.preventDefault()
    evt.stopPropagation()

    if (isPressedCtrl.value) {
      // 拖拽画布
      fabricStore.isCanvasDragging = true
      canvas.selection = false
    }
  })
}
```

这里是当按下 ctrl 的时候，给 store 中存的判断当前是否在拖拽中的 Boolean 值赋值为 true

然后就进入到 mousemove 中

```ts
// events/useMouseMove.ts
export const useMouseMove = () => {
  const fabricStore = useFabricStore()
  const [canvas] = useCanvas()
  useEventListener(fabricStore.wrapperRef, 'mousemove', (evt: MouseEvent) => {
    evt.preventDefault()
    evt.stopPropagation()

    if (isPressedCtrl.value && fabricStore.isCanvasDragging) {
      // 拖拽移动画布
      let { movementX, movementY } = evt
      if (
        (movementX === undefined || movementY === undefined)
        && previousEvent
      ) {
        movementX = evt.screenX - previousEvent?.screenX
        movementY = evt.screenY - previousEvent?.screenY
      }
      const delta = new fabric.Point(movementX, movementY)
      canvas.relativePan(delta)
      previousEvent = evt
    }
  })
}
```

这里拖拽是通过鼠标的点位，移动画布的。一点一点移动的，所以为了拖拽的流畅性，肯定是要保存上一个点的位置信息的，然后进行判断移动
所以，这里判断是当按下ctrl并且正在拖拽中，开始进行拖拽逻辑操作。

然后如果当前的这个点位和先前的那个点位都存在，进行相减，得出移动的大小

如果先前的没有，那么就当前的位置作为新的位置

以上就进行了移动，但是还没有取消移动，自然要到了mouseup

```ts
import { useFabricStore } from '~/store/modules/fabric'
export const useMouseUp = () => {
  const fabricStore = useFabricStore()
  useEventListener(fabricStore.wrapperRef, 'mouseup', (evt: MouseEvent) => {
    evt.preventDefault()
    evt.stopPropagation()

    fabricStore.isCanvasDragging = false
  })
}
```

这里只要鼠标左键松开，拖拽就停止。这里还有别的可能，之后再补充了
